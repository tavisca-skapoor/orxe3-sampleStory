var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, customElement, LitElement, property } from 'lit-element';
import { classMap } from 'lit-html/directives/class-map';
import inputContainerScss from './style-css';
const allowedChildElements = ['input', 'select'];
let OrxeInputContainer = class OrxeInputContainer extends LitElement {
    constructor() {
        super(...arguments);
        this.errorMessage = '';
        this._floatLabel = false;
        this.alwaysFloatedLabel = false;
        this._focused = false;
        this._hasContent = false;
        this.invalid = false;
        this.labelValue = '';
    }
    firstUpdated() {
        const childElement = this._selectChildElement();
        if (childElement && (childElement.placeholder || childElement.value)) {
            this.alwaysFloatedLabel = true;
        }
        if (this.alwaysFloatedLabel) {
            this._floatLabel = true;
        }
        if (childElement) {
            this._handleFocus(childElement);
            this._handleBlur(childElement);
            this._handleChange(childElement);
        }
    }
    _selectChildElement() {
        let selectedElement;
        for (let index = 0; index < allowedChildElements.length; index++) {
            const elementName = allowedChildElements[index];
            selectedElement = this.querySelector(elementName);
            if (selectedElement) {
                return selectedElement;
            }
        }
    }
    _handleFocus(childElement) {
        childElement.addEventListener('focus', () => {
            this._changeDesignState();
        });
    }
    _handleBlur(childElement) {
        childElement.addEventListener('blur', () => {
            this._changeDesignState();
        });
    }
    _handleChange(childElement) {
        childElement.addEventListener('change', (e) => {
            this._hasContent = !!e.target.value;
        });
        childElement.addEventListener('input-value-changed', (e) => {
            console.log('here: ', e);
            if (e.detail.value) {
                this._hasContent = true;
            }
            else {
                this._floatLabel = this._hasContent = false;
            }
        });
    }
    _changeDesignState() {
        if (!this.alwaysFloatedLabel) {
            this._floatLabel = !this._floatLabel;
        }
        this._focused = !this._focused;
    }
    render() {
        return html `
      <div class="orxe--input-container" ?focused=${this._focused} ?invalid-data=${this.invalid}>
        <label
          class=${classMap({
            'orxe--label': true,
            'orxe--float-label': this._floatLabel || this._hasContent,
        })}
          >${this.labelValue}
        </label>
        <div class="orxe--input-container-slotted-content">
          <slot></slot>
        </div>
      </div>
      <div class="orxe--input-container-error-message">
        ${this.invalid ? this.errorMessage : ''}
      </div>
    `;
    }
};
OrxeInputContainer.styles = inputContainerScss;
__decorate([
    property({ type: String, attribute: 'error-message' })
], OrxeInputContainer.prototype, "errorMessage", void 0);
__decorate([
    property({ type: Boolean })
], OrxeInputContainer.prototype, "_floatLabel", void 0);
__decorate([
    property({ type: Boolean, attribute: 'always-floated-label' })
], OrxeInputContainer.prototype, "alwaysFloatedLabel", void 0);
__decorate([
    property({ type: Boolean })
], OrxeInputContainer.prototype, "_focused", void 0);
__decorate([
    property({ type: Boolean })
], OrxeInputContainer.prototype, "_hasContent", void 0);
__decorate([
    property({ type: Boolean })
], OrxeInputContainer.prototype, "invalid", void 0);
__decorate([
    property({ type: String, attribute: 'label-value' })
], OrxeInputContainer.prototype, "labelValue", void 0);
OrxeInputContainer = __decorate([
    customElement('orxe-input-container')
], OrxeInputContainer);
export default OrxeInputContainer;
